#!/usr/bin/env python3

import asyncio
import errno
import os
from os import path

import discord

import config
import channel_log

client = discord.Client()

@client.event
async def on_ready():
	print('logged in as', client.user.name, client.user.id)
	for channel in client.get_all_channels():
		if channel.type == discord.ChannelType.text:
			asyncio.ensure_future(get_history(channel))

@client.event
async def on_message(message):
	channel_log.log_message(message)
	if message.clean_content.startswith('!search '):
		query = message.clean_content[8:]
		results = channel_log.search(message.server.name, message.channel.name, query)
		if not results:
			await client.send_message(message.channel, 'no results found')
			return
		output = []
		for time, user, content in results:
			output.append('[%s] %s> %s' % (time.strftime('%Y-%m-%d %H:%M:%S'), user, content))
		await client.send_message(message.channel, 'results:\n' + '\n'.join(output))

async def get_history(channel):
	channel_path = path.join(channel.server.name, channel.name)
	abspath = path.join(config.log_dir, channel_path)
	print('getting history for', channel_path)
	last_message_id = 0
	try:
		os.makedirs(abspath)
	except OSError as e:
		if e.errno != errno.EEXIST:
			raise
		log_files = os.listdir(abspath)
		if log_files:
			last_message_id = channel_log.last_message_id(path.join(abspath, max(log_files)))
	last_message = discord.Message(id=last_message_id)

	while True:
		try:
			messages = await alist(client.logs_from(channel, after=last_message))
		except discord.errors.Forbidden:
			print('no history permission for', channel_path)
			break
		if not messages:
			print('reached end of chat history for', channel_path)
			break
		messages.reverse() # messages come in reverse order
		for message in messages:
			channel_log.log_message(message)
		last_message = message

async def alist(aiterable):
	l = []
	async for item in aiterable:
		l.append(item)
	return l

if __name__ == '__main__':
	try:
		client.loop.run_until_complete(client.start(config.token))
	except KeyboardInterrupt:
		client.loop.run_until_complete(client.logout())
	finally:
		for cl in channel_log.channel_logs.values():
			cl.close()
		client.loop.close()
